# Порівняльний аналіз алгоритмів сортування

## Опис завдання
Метою завдання є порівняння ефективності трьох алгоритмів сортування:
1. Insertion Sort (сортування вставками)
2. Merge Sort (сортування злиттям)
3. Timsort (вбудований алгоритм Python).

Аналіз базується на емпіричних вимірах часу виконання алгоритмів на наборах випадкових чисел різного розміру за допомогою модуля timeit.

## Опис алгоритмів

### 1. Insertion Sort (Сортування вставками)
* **Принцип:** Проходить по масиву, вибирає елемент і вставляє його у правильну позицію серед вже відсортованих попередніх елементів.
* **Складність:** O(n^2) у середньому та найгіршому випадках.
* **Використання:** Ефективний лише на дуже малих масивах або на майже відсортованих даних.

### 2. Merge Sort (Сортування злиттям)
* **Принцип:** Використовує підхід "розділяй і володарюй". Рекурсивно ділить список навпіл до елементарних частин, а потім зливає їх у правильному порядку.
* **Складність:** O(n log n) гарантовано.
* **Використання:** Стабільний та ефективний для великих даних, але потребує додаткової пам'яті O(n).

### 3. Timsort (Вбудований sorted / .sort)
* **Принцип:** Гібридний алгоритм, що поєднує Merge Sort та Insertion Sort. Розбиває дані на невеликі шматки (runs), сортує їх вставками (бо це швидко для малих даних), а потім об'єднує злиттям.
* **Складність:** O(n log n) у середньому, O(n) у найкращому випадку.
* **Особливість:** Стабільний та ефективний для великих даних.

***

## Результати тестування

Тестування проводилося на випадково згенерованих масивах цілих чисел.
*Примітка: Час вказано в секундах (середнє значення за декілька прогонів).*

| Розмір масиву (n) | Insertion Sort | Merge Sort | Timsort (Built-in) |
| :--- | :--- | :--- | :--- |
| **100** | 0.00140 | 0.00134 | ***0.00003*** |
| **1,000** | 0.18318 | 0.01831 | ***0.00051*** |
| **5,000** | 5.33756 | 0.12114 | ***0.00399*** |
| **10,000** | Skipped | 0.25951 | ***0.00729*** |

### Інтерпретація зростання часу:
1.  **Insertion Sort**: Час зростає експоненційно. Збільшення даних у 5 разів (з 1000 до 5000) призводить до збільшення часу приблизно у 300 разів, що підтверджує складність O(n^2).
2.  **Merge Sort**: Час зростає лінійно-логарифмічно. Алгоритм стабільно справляється зі збільшенням навантаження.
3.  **Timsort**: Час виконання найменший. Навіть на 10,000 елементах він працює швидше, ніж Insertion Sort на 1,000.

***

## Висновки

### 1. Ефективність алгоритмів
Емпіричні дані підтверджують теоретичні оцінки складності:
* **Insertion Sort** є вкрай неефективним на великих наборах даних. Його доцільно використовувати тільки для масивів розміром до 50-100 елементів.
* **Merge Sort** демонструє гарну продуктивність (O(n log n)), що робить його придатним для сортування великих обсягів даних.
* **Timsort** є абсолютним переможцем.

### 2. Причини швидкості Timsort
Перевага Timsort над звичайним Merge Sort, реалізованим вручну, пояснюється двома факторами:
1.  **Алгоритмічна оптимізація:** Timsort адаптується до даних. Він використовує Insertion Sort для коротких підмасивів (де той ефективніший за Merge Sort) та спеціальні евристики для злиття вже впорядкованих частин даних.
2.  **Технічна реалізація:** Вбудована функція sorted в Python реалізована на низькому рівні мовою C, що значно скоріше інтерпретатора Python та дозволяє виконання базових операцій порівняння та переміщення пам'яті набагато швидшим.

### Підсумок
Поєднання алгоритмів (гібридний підхід) та низькорівнева оптимізація роблять Timsort набагато ефективнішим за "чисті" алгоритми, написані на високорівневій мові.

Саме тому в реальній розробці програмісти використовують вбудовані методи sorted() та .sort(), а не пишуть власні реалізації сортування.